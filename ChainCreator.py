import maya.cmds as cmd, maya.mel as mel, os, webbrowser as wb
if 'nucleusObjNumber' not in globals():
    nucleusObjNumber = int(0)
if 'hairObjNumber' not in globals():
    hairObjNumber = int(0)

def chainCreator():
    global hairObjNumber
    global nucleusObjNumber
    global readLicenseDialog
    currentMayaVersion = mel.eval('getApplicationVersionAsFloat;')
    if currentMayaVersion >= 2012:
        selection = cmd.ls(sl=1)
        selectedCurves = cmd.ls(sl=1, dag=1, ni=1, type='nurbsCurve')
        curveSection = cmd.circle(degree=1, radius=1, ch=0, name='curveSection')
        cmd.setAttr(curveSection[0] + '.intermediateObject', 1)
        if len(selectedCurves) > 0:
            for x in selectedCurves:
                transformNode = cmd.listRelatives(x, p=1)
                cmd.makeIdentity(transformNode[0], a=1, t=1, r=1, s=1, n=0)
                ringsLengthDialog = cmd.promptDialog(title='Create chain from curve', message='Length of each ring in "' + transformNode[0] + '" chain:', sf=1, st='float', tx='1.0', button=['OK', 'Cancel'], defaultButton='OK', cancelButton='Cancel', dismissString='Cancel')
                if ringsLengthDialog == 'OK':
                    ringColliderOrigin = cmd.createNode('polyCube', name='ring_collider_origin')
                    cmd.setAttr(ringColliderOrigin + '.isHistoricallyInteresting', 0)
                    ringLength = cmd.promptDialog(query=True, text=True)
                    curveLength = cmd.arclen(x, ch=0)
                    ringDistance = float(ringLength) / 10 * 7
                    numberOfRingsFloat = float(curveLength) / float(ringDistance)
                    numberOfRings = int(numberOfRingsFloat)
                    floatIntRatio = numberOfRingsFloat / float(numberOfRings)
                    heigthInitValue = float(ringLength) * floatIntRatio
                    widthInitValue = float(heigthInitValue) / 6
                    depthInitValue = float(heigthInitValue) / 2
                    print('PROCESSING CURVE: ' + transformNode[0])
                    cmd.addAttr(transformNode, ln='original_crv', nn='Original curve', at='enum', en='Hide:Show', defaultValue=0, k=0)
                    cmd.setAttr(transformNode[0] + '.original_crv', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='geo_version', nn='Geometry version', at='enum', en='Hi-Res:Proxy', defaultValue=0, k=0)
                    cmd.setAttr(transformNode[0] + '.geo_version', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='ik_fk', nn='IK_FK', at='double', defaultValue=0, k=1, min=0, max=1, h=1)
                    cmd.setAttr(transformNode[0] + '.ik_fk', lock=1)
                    cmd.addAttr(transformNode, ln='ikCtrl_fromCVs', nn='IK controls from curve cvs', at='bool', defaultValue=0, k=0)
                    cmd.setAttr(transformNode[0] + '.ikCtrl_fromCVs', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='isDynamic', nn='Is dynamic', at='bool', defaultValue=0, k=0)
                    cmd.setAttr(transformNode[0] + '.isDynamic', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='solver', nn='Dynamics solver', at='enum', en='Nucleus (better):Hair System (faster)', defaultValue=0, k=0)
                    cmd.setAttr(transformNode[0] + '.solver', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='dyn_constrain', nn='Dynamic constraint', at='enum', en='None:Start:Both:End', defaultValue=1, k=0)
                    cmd.setAttr(transformNode[0] + '.dyn_constrain', e=1, channelBox=1)
                    cmd.addAttr(transformNode, ln='ringLength', nn='Ring Length', at='double', min=0.0001, defaultValue=1, smn=1, smx=20, r=1, h=1)
                    cmd.setAttr(transformNode[0] + '.ringLength', heigthInitValue)
                    cmd.connectAttr(transformNode[0] + '.ringLength', ringColliderOrigin + '.height', f=1)
                    cmd.setAttr(transformNode[0] + '.ringLength', lock=1)
                    cmd.addAttr(transformNode, ln='ringWidth', nn='Ring Width', at='double', min=0.0001, defaultValue=1, smn=1, smx=20, r=1)
                    cmd.setAttr(transformNode[0] + '.ringWidth', depthInitValue)
                    cmd.connectAttr(transformNode[0] + '.ringWidth', ringColliderOrigin + '.depth', f=1)
                    cmd.setAttr(transformNode[0] + '.ringWidth', e=1, channelBox=1, lock=1)
                    cmd.addAttr(transformNode, ln='ringDepth', nn='Ring Depth', at='double', min=0.0001, defaultValue=1, smn=0.1, smx=5, r=1)
                    cmd.setAttr(transformNode[0] + '.ringDepth', widthInitValue)
                    cmd.connectAttr(transformNode[0] + '.ringDepth', ringColliderOrigin + '.width', f=1)
                    cmd.setAttr(transformNode[0] + '.ringDepth', e=1, channelBox=1, lock=1)
                    cmd.addAttr(transformNode, ln='squareness', nn='Profile squareness', at='double', min=0, max=1, defaultValue=0, r=1)
                    cmd.setAttr(transformNode[0] + '.squareness', e=1, channelBox=1)
                    hiResPathOrigin = cmd.createNode('makeNurbCircle', n=transformNode[0] + 'hiResPathOrigin', ss=1)
                    hiResPathTransform = cmd.createNode('transform', n=transformNode[0] + 'hiResPathTemplate', p=transformNode[0], ss=1)
                    cmd.setAttr(hiResPathTransform + '.inheritsTransform', 0)
                    hiResPathShape = cmd.createNode('nurbsCurve', p=hiResPathTransform, n=transformNode[0] + 'hiResPathTemplateShape', ss=1)
                    cmd.setAttr(hiResPathTransform + '.intermediateObject', 1)
                    cmd.setAttr(hiResPathOrigin + '.isHistoricallyInteresting', 0)
                    cmd.connectAttr(hiResPathOrigin + '.outputCurve', hiResPathShape + '.create', f=1)
                    cmd.setAttr(hiResPathOrigin + '.d', 3)
                    cmd.setAttr(hiResPathOrigin + '.radius', 0.63)
                    cmd.setAttr(hiResPathOrigin + '.s', 8)
                    cmd.move(0, -0.2, 0, hiResPathShape + '.cv[1]', r=1)
                    cmd.move(0, 0.2, 0, hiResPathShape + '.cv[5]', r=1)
                    cmd.move(0.2, 0, 0, hiResPathShape + '.cv[3]', r=1)
                    cmd.move(-0.2, 0, 0, hiResPathShape + '.cv[7]', r=1)
                    cmd.setAttr(hiResPathTransform + '.ry', 90)
                    plusMinusAverageNodeY = cmd.createNode('plusMinusAverage', ss=1, n=transformNode[0] + '_hiResGeo_scaleOffsetY')
                    plusMinusAverageNodeX = cmd.createNode('plusMinusAverage', ss=1, n=transformNode[0] + '_hiResGeo_scaleOffsetX')
                    multiplyDivideNodeXY = cmd.createNode('multiplyDivide', ss=1, n=transformNode[0] + '_hiResGeo_scaleOffsetXY_div')
                    cmd.setAttr(multiplyDivideNodeXY + '.operation', 2)
                    cmd.connectAttr(transformNode[0] + '.ringDepth', multiplyDivideNodeXY + '.input1X', f=1)
                    cmd.setAttr(multiplyDivideNodeXY + '.input2X', 2)
                    cmd.connectAttr(transformNode[0] + '.ringLength', plusMinusAverageNodeY + '.input1D[0]', f=1)
                    cmd.connectAttr(multiplyDivideNodeXY + '.outputX', plusMinusAverageNodeY + '.input1D[1]', f=1)
                    cmd.connectAttr(transformNode[0] + '.ringWidth', plusMinusAverageNodeX + '.input1D[0]', f=1)
                    cmd.connectAttr(multiplyDivideNodeXY + '.outputX', plusMinusAverageNodeX + '.input1D[1]', f=1)
                    cmd.connectAttr(plusMinusAverageNodeY + '.output1D', hiResPathTransform + '.sy', f=1)
                    cmd.connectAttr(plusMinusAverageNodeX + '.output1D', hiResPathTransform + '.sx', f=1)
                    hiResSectionOrigin = cmd.createNode('makeNurbCircle', n=transformNode[0] + 'hiResSectionOrigin', ss=1)
                    hiResSectionTransform = cmd.createNode('transform', n=transformNode[0] + 'hiResSectionTemplate', p=transformNode[0], ss=1)
                    cmd.setAttr(hiResSectionTransform + '.inheritsTransform', 0)
                    hiResSectionShape = cmd.createNode('nurbsCurve', p=hiResSectionTransform, n=transformNode[0] + 'hiResSectionTemplateShape', ss=1)
                    cmd.setAttr(hiResSectionTransform + '.intermediateObject', 1)
                    cmd.setAttr(hiResSectionOrigin + '.isHistoricallyInteresting', 0)
                    cmd.connectAttr(hiResSectionOrigin + '.outputCurve', hiResSectionShape + '.create', f=1)
                    cmd.setAttr(hiResSectionOrigin + '.d', 3)
                    cmd.setAttr(hiResSectionOrigin + '.radius', 0.5)
                    cmd.setAttr(hiResSectionOrigin + '.s', 8)
                    cmd.connectAttr(transformNode[0] + '.ringDepth', hiResSectionTransform + '.sx', f=1)
                    cmd.connectAttr(transformNode[0] + '.ringDepth', hiResSectionTransform + '.sy', f=1)
                    cmd.connectAttr(transformNode[0] + '.ringDepth', hiResSectionTransform + '.sz', f=1)
                    cmd.setAttr(hiResSectionShape + '.cv[0].xValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[0].yValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[0].zValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[2].xValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[2].yValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[2].zValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[4].xValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[4].yValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[4].zValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[6].xValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[6].yValue', l=1)
                    cmd.setAttr(hiResSectionShape + '.cv[6].zValue', l=1)
                    squarenessMultDivNode1 = cmd.createNode('multiplyDivide', name=transformNode[0] + '_squareness_multDiv1', ss=1)
                    squarenessMultDivNode2 = cmd.createNode('multiplyDivide', name=transformNode[0] + '_squareness_multDiv2', ss=1)
                    cmd.connectAttr(transformNode[0] + '.squareness', squarenessMultDivNode1 + '.input1X', f=1)
                    cmd.connectAttr(transformNode[0] + '.squareness', squarenessMultDivNode1 + '.input1Y', f=1)
                    cmd.connectAttr(transformNode[0] + '.squareness', squarenessMultDivNode1 + '.input1Z', f=1)
                    cmd.connectAttr(transformNode[0] + '.squareness', squarenessMultDivNode2 + '.input1X', f=1)
                    cmd.setAttr(squarenessMultDivNode1 + '.input2X', -0.4)
                    cmd.setAttr(squarenessMultDivNode1 + '.input2Y', 0.4)
                    cmd.setAttr(squarenessMultDivNode1 + '.input2Z', 0.4)
                    cmd.setAttr(squarenessMultDivNode2 + '.input2X', -0.4)
                    cmd.connectAttr(squarenessMultDivNode1 + '.outputX', hiResSectionShape + '.cv[1].yValue', f=1)
                    cmd.connectAttr(squarenessMultDivNode1 + '.outputY', hiResSectionShape + '.cv[3].xValue', f=1)
                    cmd.connectAttr(squarenessMultDivNode1 + '.outputZ', hiResSectionShape + '.cv[5].yValue', f=1)
                    cmd.connectAttr(squarenessMultDivNode2 + '.outputX', hiResSectionShape + '.cv[7].xValue', f=1)
                    cmd.setAttr(squarenessMultDivNode1 + '.isHistoricallyInteresting', 0)
                    cmd.setAttr(squarenessMultDivNode2 + '.isHistoricallyInteresting', 0)
                    hiResGeoTemplate = cmd.extrude(hiResSectionShape, hiResPathShape, et=2, ch=1, fpt=1, ucp=1, upn=1, sc=1, n=transformNode[0] + 'hiResRingTemplate')
                    cmd.parent(hiResGeoTemplate[0], transformNode[0])
                    cmd.setAttr(hiResGeoTemplate[0] + '.intermediateObject', 1)
                    rebuildNode = cmd.createNode('rebuildCurve', name=transformNode[0] + '_rebuild', ss=1)
                    cmd.setAttr(rebuildNode + '.kt', 1)
                    cmd.setAttr(rebuildNode + '.degree', 1)
                    cmd.setAttr(rebuildNode + '.spans', numberOfRings)
                    cmd.connectAttr(x + '.worldSpace', rebuildNode + '.inputCurve', f=1)
                    newCurve = cmd.createNode('nurbsCurve', name=x + '_new', ss=1, parent=transformNode[0])
                    cmd.connectAttr(rebuildNode + '.outputCurve', newCurve + '.create', f=1)
                    nurbsPath = cmd.extrude(curveSection, newCurve, et=2, fpt=1, ucp=1, upn=1, name=transformNode[0] + '_extrudedPath')
                    cmd.parent(nurbsPath[0], transformNode)
                    upCurve = cmd.duplicateCurve(nurbsPath[0] + '.u[0]', name=transformNode[0] + '_upCurve', ch=1, rn=0, local=0)
                    cmd.parent(upCurve[0], transformNode)
                    upCurve = cmd.reverseCurve(upCurve[0], ch=1, rpo=1)
                    rebuildNodeForHair = cmd.createNode('rebuildCurve', name=transformNode[0] + '_rebuildForHairSystem', ss=1)
                    hairSystemInScene = cmd.ls('chain_hairSystemShape', type='hairSystem', dag=1)
                    if len(hairSystemInScene) > 0:
                        hairSystemNode = hairSystemInScene[0]
                    else:
                        hairSystemTransform = cmd.createNode('transform', name='chain_hairSystem')
                        hairSystemNode = cmd.createNode('hairSystem', name='chain_hairSystemShape', p=hairSystemTransform)
                        cmd.connectAttr('time1.outTime', hairSystemNode + '.currentTime', f=1)
                        cmd.setAttr(hairSystemNode + '.gravity', 3.5)
                        cmd.setAttr(hairSystemNode + '.simulationMethod', 3)
                        cmd.setAttr(hairSystemNode + '.isHistoricallyInteresting', 0)
                        cmd.setAttr(hairSystemNode + '.selfCollide', 1)
                        cmd.setAttr(hairSystemNode + '.stiffness', 0)
                        cmd.setAttr(hairSystemNode + '.stiffness', lock=1)
                        cmd.setAttr(hairSystemNode + '.damp', 0.05)
                        cmd.setAttr(hairSystemNode + '.iterations', 25)
                        cmd.setAttr(hairSystemNode + '.noStretch', 1)
                    chainFollicle = cmd.createNode('follicle', name=transformNode[0] + '_follicle', ss=1, parent=transformNode[0])
                    hairInputCurveTransform = cmd.createNode('transform', name=transformNode[0] + '_rebuildForHairSystem', ss=1, parent=transformNode[0])
                    hairInputCurve = cmd.createNode('nurbsCurve', name=transformNode[0] + '_rebuildForHairSystemShape', ss=1, parent=hairInputCurveTransform)
                    hairOutputCurve = cmd.createNode('nurbsCurve', name=transformNode[0] + '_hairOPcurve', ss=1, parent=transformNode[0])
                    cmd.setAttr(hairInputCurveTransform + '.inheritsTransform', 0)
                    cmd.setAttr(hairInputCurveTransform + '.isHistoricallyInteresting', 0)
                    cmd.setAttr(rebuildNodeForHair + '.rebuildType', 0)
                    cmd.setAttr(rebuildNodeForHair + '.isHistoricallyInteresting', 0)
                    cmd.setAttr(rebuildNodeForHair + '.spans', numberOfRings * 3)
                    cmd.setAttr(rebuildNodeForHair + '.kt', 1)
                    cmd.setAttr(rebuildNodeForHair + '.degree', 3)
                    cmd.setAttr(hairInputCurveTransform + '.intermediateObject', 1)
                    cmd.setAttr(hairInputCurve + '.isHistoricallyInteresting', 0)
                    cmd.setAttr(hairOutputCurve + '.intermediateObject', 1)
                    cmd.setAttr(chainFollicle + '.simulationMethod', 0)
                    cmd.setAttr(chainFollicle + '.visibility', 0)
                    cmd.setAttr(chainFollicle + '.isHistoricallyInteresting', 0)
                    cmd.connectAttr(x + '.worldSpace', rebuildNodeForHair + '.inputCurve', f=1)
                    cmd.connectAttr(rebuildNodeForHair + '.outputCurve', hairInputCurve + '.create', f=1)
                    cmd.connectAttr(hairInputCurve + '.worldSpace', chainFollicle + '.startPosition', f=1)
                    cmd.connectAttr(chainFollicle + '.outCurve', hairOutputCurve + '.create', f=1)
                    cmd.connectAttr(chainFollicle + '.outHair', hairSystemNode + '.inputHair[' + str(hairObjNumber) + ']', f=1)
                    cmd.connectAttr(hairSystemNode + '.outputHair[' + str(hairObjNumber) + ']', chainFollicle + '.currentPosition', f=1)
                    hairObjNumber += 1
                    targetLocatorGroup = cmd.createNode('transform', name=transformNode[0] + '_targetLocatorGRP', ss=1, parent=transformNode[0])
                    upLocatorGroup = cmd.createNode('transform', name=transformNode[0] + '_upLocatorGRP', ss=1, parent=transformNode[0])
                    ringsGeoGroup = cmd.createNode('transform', name=transformNode[0] + '_ringsGeoGRP', ss=1, parent=transformNode[0])
                    ringsCollidersGroup = cmd.createNode('transform', name=transformNode[0] + '_ringsCollidersGRP', ss=1, parent=transformNode[0])
                    jointGroup = cmd.createNode('transform', name=transformNode[0] + '_jointGRP', ss=1, parent=transformNode[0])
                    hiresJointGroup = cmd.createNode('transform', name=transformNode[0] + '_hiRes_jointGRP', ss=1, parent=transformNode[0])
                    clusterGroup = cmd.createNode('transform', name=transformNode[0] + '_clusterGRP', ss=1, parent=jointGroup)
                    ikControlsGroup = cmd.createNode('transform', name=transformNode[0] + '_ik_controlsGRP', ss=1, parent=transformNode[0])
                    cmd.setAttr(ringsGeoGroup + '.translate', k=0, l=1, cb=0)
                    cmd.setAttr(ringsGeoGroup + '.rotate', k=0, l=1, cb=0)
                    cmd.setAttr(ringsGeoGroup + '.scale', k=0, l=1, cb=0)
                    cmd.setAttr(ringsCollidersGroup + '.translate', k=0, l=1, cb=0)
                    cmd.setAttr(ringsCollidersGroup + '.rotate', k=0, l=1, cb=0)
                    cmd.setAttr(ringsCollidersGroup + '.scale', k=0, l=1, cb=0)
                    cmd.setAttr(ikControlsGroup + '.translate', k=0, l=1, cb=0)
                    cmd.setAttr(ikControlsGroup + '.rotate', k=0, l=1, cb=0)
                    cmd.setAttr(ikControlsGroup + '.scale', k=0, l=1, cb=0)
                    cmd.setAttr(ringsGeoGroup + '.inheritsTransform', 0)
                    cmd.setAttr(ringsCollidersGroup + '.inheritsTransform', 0)
                    collidersGroupOne = []
                    collidersGroupTwo = []
                    hiResGroupOne = []
                    hiResGroupTwo = []
                    jointsGroupOne = []
                    jointsGroupTwo = []
                    firstJoint = []
                    lastJointForIK = []
                    for y in range(0, numberOfRings, 1):
                        upLocatorTransform = cmd.createNode('transform', name=transformNode[0] + '_upLocator_' + str(y), ss=1, parent=upLocatorGroup)
                        upLocator = cmd.createNode('locator', name=transformNode[0] + '_up_locatorShp_' + str(y), ss=1, parent=upLocatorTransform)
                        upPosition = cmd.xform(upCurve[0] + '.ep[' + str(y) + ']', t=1, q=1, ws=1)
                        cmd.setAttr(upLocatorTransform + '.tx', upPosition[0])
                        cmd.setAttr(upLocatorTransform + '.ty', upPosition[1])
                        cmd.setAttr(upLocatorTransform + '.tz', upPosition[2])
                        targetLocatorTransform = cmd.createNode('transform', name=transformNode[0] + '_targetLocator_' + str(y), ss=1, parent=targetLocatorGroup)
                        targetLocator = cmd.createNode('locator', name=transformNode[0] + '_target_locatorShp_' + str(y), ss=1, parent=targetLocatorTransform)
                        targetPosition = cmd.xform(newCurve + '.ep[' + str(y) + ']', t=1, q=1, ws=1)
                        cmd.setAttr(targetLocatorTransform + '.tx', targetPosition[0])
                        cmd.setAttr(targetLocatorTransform + '.ty', targetPosition[1])
                        cmd.setAttr(targetLocatorTransform + '.tz', targetPosition[2])
                        tangentCNS = cmd.tangentConstraint(x, targetLocatorTransform, name=transformNode[0] + '_tangent_CNS_' + str(y), wut='objectrotation', aim=(0,
                                                                                                                                                                   1,
                                                                                                                                                                   0), u=(1,
                                                                                                                                                                          0,
                                                                                                                                                                          0), wuo=upLocatorTransform)
                        tangentCNSTwo = cmd.tangentConstraint(x, targetLocatorTransform, name=transformNode[0] + '_tangent_CNS_' + str(y), wut='object', aim=(0,
                                                                                                                                                              1,
                                                                                                                                                              0), u=(1,
                                                                                                                                                                     0,
                                                                                                                                                                     0), wuo=upLocatorTransform)
                        ringColliderTransform = cmd.createNode('transform', name=transformNode[0] + '_ringCollider_' + str(y), ss=1, p=ringsCollidersGroup)
                        ringColliderShape = cmd.createNode('mesh', name=transformNode[0] + '_ringCollider_' + str(y) + '_Shape', ss=1, p=ringColliderTransform)
                        cmd.connectAttr(ringColliderOrigin + '.output', ringColliderShape + '.inMesh', f=1)
                        cmd.delete(ringColliderShape + '.f[4]', ringColliderShape + '.f[5]')
                        ringColliderPointCNS = cmd.pointConstraint(targetLocatorTransform, ringColliderTransform)
                        ringColliderOrientCNS = cmd.orientConstraint(targetLocatorTransform, ringColliderTransform)
                        hiResRingTransform = cmd.createNode('transform', name=transformNode[0] + '_ring_' + str(y), ss=1, p=ringsGeoGroup)
                        hiResRingShape = cmd.createNode('nurbsSurface', name=transformNode[0] + '_ring_' + str(y) + '_Shape', ss=1, p=hiResRingTransform)
                        cmd.connectAttr(hiResGeoTemplate[1] + '.outputSurface', hiResRingShape + '.create', f=1)
                        HRPointCNS = cmd.pointConstraint(targetLocatorTransform, hiResRingTransform)
                        HROrientCNS = cmd.orientConstraint(targetLocatorTransform, hiResRingTransform)
                        jointPosTransform = cmd.createNode('transform', n=transformNode[0] + '_jointPos_' + str(y), ss=1, p=targetLocatorTransform)
                        cmd.setAttr(jointPosTransform + '.ty', heigthInitValue / 2 * -1)
                        cmd.parent(jointPosTransform, w=1)
                        jointPosX = cmd.getAttr(jointPosTransform + '.tx')
                        jointPosY = cmd.getAttr(jointPosTransform + '.ty')
                        jointPosZ = cmd.getAttr(jointPosTransform + '.tz')
                        cmd.delete(jointPosTransform)
                        if y == 0:
                            cmd.select(jointGroup, r=1)
                            ringJoint = cmd.joint(p=(jointPosX, jointPosY, jointPosZ), name=transformNode[0] + '_joint_' + str(y))
                            ringJointOne = ringJoint
                            jointControl = cmd.circle(nr=(1, 0, 0), degree=1, radius=depthInitValue * 1.2, ch=0, name=transformNode[0] + '_jointControlTemplate_' + str(y))
                            jointControlShape = cmd.ls(jointControl, dag=1)
                            cmd.parent(jointControlShape[1], ringJoint, add=1, s=1)
                            cmd.delete(jointControlShape[0])
                            firstJoint.append(ringJoint)
                        else:
                            cmd.select(ringJoint, r=1)
                            ringJoint = cmd.joint(p=(jointPosX, jointPosY, jointPosZ), name=transformNode[0] + '_joint_' + str(y))
                            jointControl = cmd.circle(nr=(1, 0, 0), degree=1, radius=depthInitValue * 1.2, ch=0, name=transformNode[0] + '_jointControlTemplate_' + str(y))
                            jointControlShape = cmd.ls(jointControl, dag=1)
                            cmd.parent(jointControlShape[1], ringJoint, add=1, s=1)
                            cmd.delete(jointControlShape[0])
                            if y == numberOfRings - 1:
                                lastEpCoords = cmd.xform(newCurve + '.ep[' + str(numberOfRings) + ']', t=1, q=1, ws=1)
                                cmd.select(ringJoint, r=1)
                                jointForLastEP = cmd.joint(p=(lastEpCoords[0], lastEpCoords[1], lastEpCoords[2]), name=transformNode[0] + '_endJoint_' + str(numberOfRings))
                                cmd.setAttr(jointForLastEP + '.radius', 0)
                                cmd.setAttr(jointForLastEP + '.overrideEnabled', 1)
                                cmd.setAttr(jointForLastEP + '.overrideColor', 9)
                                lastJointForIK.append(jointForLastEP)
                            cmd.joint(ringJointOne, e=1, oj='xyz', sao='yup', ch=1, zso=1)
                        divisibleByTwoCheck = y % 2
                        if divisibleByTwoCheck == 0:
                            cmd.setAttr(tangentCNS[0] + '.upVectorX', 0)
                            cmd.setAttr(tangentCNS[0] + '.upVectorZ', 1)
                            cmd.setAttr(ringJoint + '.overrideEnabled', 1)
                            cmd.setAttr(ringJoint + '.overrideColor', 14)
                            cmd.setAttr(ringJoint + '.radius', 0)
                            collidersGroupOne.append(ringColliderTransform)
                            jointsGroupOne.append(ringJoint)
                            hiResGroupOne.append(hiResRingShape)
                        else:
                            cmd.setAttr(ringJoint + '.overrideEnabled', 1)
                            cmd.setAttr(ringJoint + '.overrideColor', 6)
                            cmd.setAttr(ringJoint + '.radius', 0)
                            collidersGroupTwo.append(ringColliderTransform)
                            jointsGroupTwo.append(ringJoint)
                            hiResGroupTwo.append(hiResRingShape)
                        cmd.delete(ringColliderPointCNS)
                        cmd.delete(ringColliderOrientCNS)
                        cmd.delete(HRPointCNS, HROrientCNS)

                    chainColliderPartOne = cmd.polyUnite(collidersGroupOne, ch=1, n=transformNode[0] + '_chainCollider_Part1')
                    cmd.setAttr(chainColliderPartOne[1] + '.isHistoricallyInteresting', 0)
                    for elementOfGroupOne in collidersGroupOne:
                        cmd.setAttr(elementOfGroupOne + '.intermediateObject', 1)

                    cmd.parent(chainColliderPartOne[0], ringsCollidersGroup)
                    nclothRestForPart1 = cmd.duplicate(chainColliderPartOne[0], n=transformNode[0] + '_chainCollider_Part1_rest', ic=1, rc=1)
                    chainColliderPartTwo = cmd.polyUnite(collidersGroupTwo, ch=1, n=transformNode[0] + '_chainCollider_Part2')
                    cmd.setAttr(chainColliderPartTwo[1] + '.isHistoricallyInteresting', 0)
                    for elementOfGroupTwo in collidersGroupTwo:
                        cmd.setAttr(elementOfGroupTwo + '.intermediateObject', 1)

                    cmd.parent(chainColliderPartTwo[0], ringsCollidersGroup)
                    nclothRestForPart2 = cmd.duplicate(chainColliderPartTwo[0], n=transformNode[0] + '_chainCollider_Part2_rest', ic=1, rc=1)
                    collidersGroupOneNumber = len(collidersGroupOne)
                    collidersGroupTwoNumber = len(collidersGroupTwo)
                    partitionSetsGroupOne = []
                    partitionSetsGroupTwo = []
                    for n in range(0, collidersGroupOneNumber, 1):
                        min = n * 8
                        max = min + 7
                        cmd.select(chainColliderPartOne[0] + '.vtx[' + str(min) + ':' + str(max) + ']', r=1)
                        vertexSet = cmd.sets(v=1, n=transformNode[0] + '_collider_partOne_vertexSet_' + str(n))
                        cmd.setAttr(vertexSet + '.isHistoricallyInteresting', 0)
                        partitionSetsGroupOne.append(vertexSet)

                    for m in range(0, collidersGroupTwoNumber, 1):
                        min = m * 8
                        max = min + 7
                        cmd.select(chainColliderPartTwo[0] + '.vtx[' + str(min) + ':' + str(max) + ']', r=1)
                        vertexSet = cmd.sets(v=1, n=transformNode[0] + '_collider_partOne_vertexSet_' + str(m))
                        cmd.setAttr(vertexSet + '.isHistoricallyInteresting', 0)
                        partitionSetsGroupTwo.append(vertexSet)

                    colliderOneVtxPartition = cmd.partition(partitionSetsGroupOne, n=transformNode[0] + '_chainCollider_Part1_partition')
                    cmd.setAttr(colliderOneVtxPartition + '.isHistoricallyInteresting', 0)
                    colliderTwoVtxPartition = cmd.partition(partitionSetsGroupTwo, n=transformNode[0] + '_chainCollider_Part2_partition')
                    cmd.setAttr(colliderTwoVtxPartition + '.isHistoricallyInteresting', 0)
                    skinForPartOne = cmd.bindSkin(chainColliderPartOne[0], jointsGroupOne, bp=1, p=colliderOneVtxPartition, dnd=1, tsb=1)
                    cmd.setAttr(skinForPartOne + '.isHistoricallyInteresting', 0)
                    skinForPartTwo = cmd.bindSkin(chainColliderPartTwo[0], jointsGroupTwo, bp=1, p=colliderTwoVtxPartition, dnd=1, tsb=1)
                    cmd.setAttr(skinForPartTwo + '.isHistoricallyInteresting', 0)
                    nucleusInScene = cmd.ls('chain_nucleus', type='nucleus')
                    if len(nucleusInScene) > 0:
                        nucleusNode = nucleusInScene[0]
                    else:
                        nucleusNode = cmd.createNode('nucleus', name='chain_nucleus')
                        cmd.connectAttr('time1.outTime', nucleusNode + '.currentTime', f=1)
                    nclothTransformForPart1 = cmd.createNode('transform', name=transformNode[0] + '_chainCollider_Part1_nCloth', ss=1, parent=ringsCollidersGroup)
                    nclothTransformForPart2 = cmd.createNode('transform', name=transformNode[0] + '_chainCollider_Part2_nCloth', ss=1, parent=ringsCollidersGroup)
                    nclothShapeForPart1 = cmd.createNode('nCloth', name=transformNode[0] + '_chainCollider_Part1_nClothShape', ss=1, parent=nclothTransformForPart1)
                    nclothShapeForPart2 = cmd.createNode('nCloth', name=transformNode[0] + '_chainCollider_Part2_nClothShape', ss=1, parent=nclothTransformForPart2)
                    nclothOutputForPart1 = cmd.createNode('mesh', name=transformNode[0] + '_chainCollider_Part1_outputCloth', ss=1, parent=chainColliderPartOne[0])
                    nclothOutputForPart2 = cmd.createNode('mesh', name=transformNode[0] + '_chainCollider_Part2_outputCloth', ss=1, parent=chainColliderPartTwo[0])
                    cmd.connectAttr(nclothRestForPart1[0] + 'Shape.worldMesh[0]', nclothShapeForPart1 + '.restShapeMesh', f=1)
                    cmd.connectAttr(nclothRestForPart2[0] + 'Shape.worldMesh[0]', nclothShapeForPart2 + '.restShapeMesh', f=1)
                    cmd.setAttr(chainColliderPartOne[0] + 'Shape.intermediateObject', 1)
                    cmd.setAttr(chainColliderPartTwo[0] + 'Shape.intermediateObject', 1)
                    cmd.setAttr(nclothRestForPart1[0] + '.intermediateObject', 1)
                    cmd.setAttr(nclothRestForPart2[0] + '.intermediateObject', 1)
                    cmd.connectAttr(chainColliderPartOne[0] + 'Shape.worldMesh[0]', nclothShapeForPart1 + '.inputMesh', f=1)
                    cmd.connectAttr('time1.outTime', nclothShapeForPart1 + '.currentTime', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.startState', nucleusNode + '.inputActiveStart' + '[' + str(nucleusObjNumber) + ']', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.currentState', nucleusNode + '.inputActive' + '[' + str(nucleusObjNumber) + ']', f=1)
                    cmd.connectAttr(nucleusNode + '.startFrame', nclothShapeForPart1 + '.startFrame', f=1)
                    cmd.connectAttr(nucleusNode + '.outputObjects' + '[' + str(nucleusObjNumber) + ']', nclothShapeForPart1 + '.nextState', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.outputMesh', nclothOutputForPart1 + '.inMesh', f=1)
                    nucleusObjNumber += 1
                    cmd.connectAttr(chainColliderPartTwo[0] + 'Shape.worldMesh[0]', nclothShapeForPart2 + '.inputMesh', f=1)
                    cmd.connectAttr('time1.outTime', nclothShapeForPart2 + '.currentTime', f=1)
                    cmd.connectAttr(nclothShapeForPart2 + '.startState', nucleusNode + '.inputActiveStart' + '[' + str(nucleusObjNumber) + ']', f=1)
                    cmd.connectAttr(nclothShapeForPart2 + '.currentState', nucleusNode + '.inputActive' + '[' + str(nucleusObjNumber) + ']', f=1)
                    cmd.connectAttr(nucleusNode + '.startFrame', nclothShapeForPart2 + '.startFrame', f=1)
                    cmd.connectAttr(nucleusNode + '.outputObjects' + '[' + str(nucleusObjNumber) + ']', nclothShapeForPart2 + '.nextState', f=1)
                    cmd.connectAttr(nclothShapeForPart2 + '.outputMesh', nclothOutputForPart2 + '.inMesh', f=1)
                    nucleusObjNumber += 1
                    cmd.setAttr(ringsCollidersGroup + '.visibility', 0)
                    cmd.select(nclothOutputForPart1 + '.vtx[0:7]')
                    mel.eval('createNConstraint transform true;')
                    startConstraint = cmd.ls(sl=1)
                    startConstraintTransform = cmd.listRelatives(startConstraint, p=1)
                    startConstraintTransform = cmd.rename(startConstraintTransform, transformNode[0] + '_startChain_nConstraint')
                    cmd.parent(startConstraintTransform, ringsCollidersGroup)
                    numberOfRingsDivisibleByTwoCheck = numberOfRings % 2
                    if numberOfRingsDivisibleByTwoCheck == 1:
                        firstVtx = (collidersGroupOneNumber - 1) * 8
                        lastVtx = firstVtx + 7
                        cmd.select(nclothOutputForPart1 + '.vtx[' + str(firstVtx) + ':' + str(lastVtx) + ']')
                    else:
                        firstVtx = (collidersGroupTwoNumber - 1) * 8
                        lastVtx = firstVtx + 7
                        cmd.select(nclothOutputForPart2 + '.vtx[' + str(firstVtx) + ':' + str(lastVtx) + ']')
                    mel.eval('createNConstraint transform true;')
                    endConstraint = cmd.ls(sl=1)
                    endConstraintTransform = cmd.listRelatives(endConstraint, p=1)
                    endConstraintTransform = cmd.rename(endConstraintTransform, transformNode[0] + '_endChain_nConstraint')
                    cmd.parent(endConstraintTransform, ringsCollidersGroup)
                    cmd.connectAttr(transformNode[0] + '.original_crv', x + '.visibility', f=1)
                    cmd.connectAttr(transformNode[0] + '.geo_version', ringsCollidersGroup + '.visibility', f=1)
                    cmd.setAttr(ringsCollidersGroup + '.visibility', l=1)
                    visibilityConditionNode = cmd.createNode('condition', name=transformNode[0] + '_visibility_condition_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.geo_version', visibilityConditionNode + '.firstTerm', f=1)
                    cmd.setAttr(visibilityConditionNode + '.secondTerm', 1)
                    cmd.setAttr(visibilityConditionNode + '.operation', 0)
                    cmd.setAttr(visibilityConditionNode + '.colorIfTrueR', 0)
                    cmd.setAttr(visibilityConditionNode + '.colorIfFalseR', 1)
                    cmd.connectAttr(visibilityConditionNode + '.outColor.outColorR', ringsGeoGroup + '.visibility', f=1)
                    cmd.setAttr(ringsGeoGroup + '.visibility', l=1)
                    conditionNodeZero = cmd.createNode('condition', name=transformNode[0] + '_dynamicMethod_condition_', ss=1)
                    zeroMultDivNode = cmd.createNode('multiplyDivide', name=transformNode[0] + '_dynamicMethod_condition_mult', ss=1)
                    cmd.setAttr(conditionNodeZero + '.isHistoricallyInteresting', 0)
                    cmd.setAttr(zeroMultDivNode + '.isHistoricallyInteresting', 0)
                    cmd.connectAttr(transformNode[0] + '.isDynamic', zeroMultDivNode + '.input1X', f=1)
                    cmd.connectAttr(transformNode[0] + '.isDynamic', zeroMultDivNode + '.input1Y', f=1)
                    cmd.setAttr(zeroMultDivNode + '.operation', 1)
                    cmd.connectAttr(transformNode[0] + '.solver', conditionNodeZero + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeZero + '.secondTerm', 0)
                    cmd.setAttr(conditionNodeZero + '.operation', 0)
                    cmd.setAttr(conditionNodeZero + '.colorIfTrueR', 1)
                    cmd.setAttr(conditionNodeZero + '.colorIfFalseR', 0)
                    cmd.setAttr(conditionNodeZero + '.colorIfTrueG', 0)
                    cmd.setAttr(conditionNodeZero + '.colorIfFalseG', 2)
                    cmd.connectAttr(conditionNodeZero + '.outColorR', zeroMultDivNode + '.input2X', f=1)
                    cmd.connectAttr(conditionNodeZero + '.outColorG', zeroMultDivNode + '.input2Y', f=1)
                    opcIntermediateConditionNode = cmd.createNode('condition', name=transformNode[0] + '_OPCintermediate', ss=1)
                    cmd.connectAttr(zeroMultDivNode + '.outputY', opcIntermediateConditionNode + '.firstTerm', f=1)
                    cmd.setAttr(opcIntermediateConditionNode + '.secondTerm', 2)
                    cmd.setAttr(opcIntermediateConditionNode + '.operation', 0)
                    cmd.setAttr(opcIntermediateConditionNode + '.colorIfTrueR', 0)
                    cmd.setAttr(opcIntermediateConditionNode + '.colorIfFalseR', 1)
                    cmd.connectAttr(opcIntermediateConditionNode + '.outColorR', hairOutputCurve + '.intermediateObject', f=1)
                    cmd.setAttr(opcIntermediateConditionNode + '.isHistoricallyInteresting', 0)
                    cmd.connectAttr(zeroMultDivNode + '.outputX', nclothShapeForPart1 + '.isDynamic', f=1)
                    cmd.connectAttr(zeroMultDivNode + '.outputX', nclothShapeForPart2 + '.isDynamic', f=1)
                    cmd.connectAttr(zeroMultDivNode + '.outputY', chainFollicle + '.simulationMethod', f=1)
                    conditionNodeOne = cmd.createNode('condition', name=transformNode[0] + '_isDynamic_condition_', ss=1)
                    cmd.connectAttr(zeroMultDivNode + '.outputX', conditionNodeOne + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeOne + '.secondTerm', 1)
                    cmd.setAttr(conditionNodeOne + '.operation', 0)
                    cmd.setAttr(conditionNodeOne + '.colorIfTrueR', 1)
                    cmd.setAttr(conditionNodeOne + '.colorIfFalseR', 100000)
                    cmd.setAttr(conditionNodeOne + '.colorIfTrueG', 0)
                    cmd.setAttr(conditionNodeOne + '.colorIfFalseG', 1)
                    cmd.connectAttr(conditionNodeOne + '.outColor.outColorR', nclothShapeForPart1 + '.startFrame', f=1)
                    cmd.connectAttr(conditionNodeOne + '.outColor.outColorR', nclothShapeForPart2 + '.startFrame', f=1)
                    cmd.connectAttr(conditionNodeOne + '.outColor.outColorG', jointGroup + '.visibility', f=1)
                    cmd.setAttr(conditionNodeOne + '.isHistoricallyInteresting', 0)
                    conditionNodeTwo = cmd.createNode('condition', name=transformNode[0] + '_ik_visibility_driver_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.ik_fk', conditionNodeTwo + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeTwo + '.secondTerm', 1)
                    cmd.setAttr(conditionNodeTwo + '.operation', 0)
                    cmd.setAttr(conditionNodeTwo + '.colorIfTrueR', 0)
                    cmd.setAttr(conditionNodeTwo + '.colorIfFalseR', 1)
                    cmd.connectAttr(conditionNodeTwo + '.outColor.outColorR', clusterGroup + '.visibility', f=1)
                    cmd.setAttr(conditionNodeTwo + '.isHistoricallyInteresting', 0)
                    conditionNodeThree = cmd.createNode('condition', name=transformNode[0] + '_fk_visibility_driver_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.ik_fk', conditionNodeThree + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeThree + '.secondTerm', 0)
                    cmd.setAttr(conditionNodeThree + '.operation', 0)
                    cmd.setAttr(conditionNodeThree + '.colorIfTrueR', 0)
                    cmd.setAttr(conditionNodeThree + '.colorIfFalseR', 1)
                    cmd.connectAttr(conditionNodeThree + '.outColor.outColorR', firstJoint[0] + '.visibility', f=1)
                    cmd.setAttr(conditionNodeThree + '.isHistoricallyInteresting', 0)
                    conditionNodeFour = cmd.createNode('condition', name=transformNode[0] + '_dynamicCNS_active_driver1_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.dyn_constrain', conditionNodeFour + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeFour + '.secondTerm', 0)
                    cmd.setAttr(conditionNodeFour + '.operation', 2)
                    cmd.setAttr(conditionNodeFour + '.colorIfTrueR', 1)
                    cmd.setAttr(conditionNodeFour + '.colorIfFalseR', 0)
                    cmd.setAttr(conditionNodeFour + '.isHistoricallyInteresting', 0)
                    conditionNodeFive = cmd.createNode('condition', name=transformNode[0] + '_dynamicCNS_active_driver2_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.dyn_constrain', conditionNodeFive + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeFive + '.secondTerm', 3)
                    cmd.setAttr(conditionNodeFive + '.operation', 4)
                    cmd.setAttr(conditionNodeFive + '.colorIfTrueR', 1)
                    cmd.setAttr(conditionNodeFive + '.colorIfFalseR', 0)
                    cmd.setAttr(conditionNodeFive + '.isHistoricallyInteresting', 0)
                    fourAndFiveMultiplyNode = cmd.createNode('multiplyDivide', name=transformNode[0] + '_dynamicCNS_active_mult_div_', ss=1)
                    cmd.connectAttr(conditionNodeFour + '.outColor.outColorR', fourAndFiveMultiplyNode + '.input1X', f=1)
                    cmd.connectAttr(conditionNodeFive + '.outColor.outColorR', fourAndFiveMultiplyNode + '.input2X', f=1)
                    startConstraintShape = cmd.ls(startConstraintTransform, dag=1)
                    cmd.connectAttr(fourAndFiveMultiplyNode + '.outputX', startConstraintShape[0] + '.ena', f=1)
                    cmd.setAttr(fourAndFiveMultiplyNode + '.isHistoricallyInteresting', 0)
                    conditionNodeSix = cmd.createNode('condition', name=transformNode[0] + '_dynamicCNS_active_driver3_', ss=1)
                    cmd.connectAttr(transformNode[0] + '.dyn_constrain', conditionNodeSix + '.firstTerm', f=1)
                    cmd.setAttr(conditionNodeSix + '.secondTerm', 1)
                    cmd.setAttr(conditionNodeSix + '.operation', 2)
                    cmd.setAttr(conditionNodeSix + '.colorIfTrueR', 1)
                    cmd.setAttr(conditionNodeSix + '.colorIfFalseR', 0)
                    endConstraintShape = cmd.ls(endConstraintTransform, dag=1)
                    cmd.connectAttr(conditionNodeSix + '.outColor.outColorR', endConstraintShape[0] + '.ena', f=1)
                    cmd.setAttr(conditionNodeSix + '.isHistoricallyInteresting', 0)
                    cmd.setDrivenKeyframe(chainFollicle + '.pointLock', cd=transformNode[0] + '.dyn_constrain', dv=0, v=0)
                    cmd.setDrivenKeyframe(chainFollicle + '.pointLock', cd=transformNode[0] + '.dyn_constrain', dv=1, v=1)
                    cmd.setDrivenKeyframe(chainFollicle + '.pointLock', cd=transformNode[0] + '.dyn_constrain', dv=2, v=3)
                    cmd.setDrivenKeyframe(chainFollicle + '.pointLock', cd=transformNode[0] + '.dyn_constrain', dv=3, v=2)
                    cmd.setAttr(nclothShapeForPart1 + '.collisionFlag', 2)
                    cmd.setAttr(nclothShapeForPart1 + '.stretchResistance', 200)
                    cmd.setAttr(nclothShapeForPart1 + '.compressionResistance', 1000)
                    cmd.setAttr(nclothShapeForPart1 + '.bendResistance', 200)
                    cmd.connectAttr(nclothShapeForPart1 + '.collisionFlag', nclothShapeForPart2 + '.collisionFlag', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.stretchResistance', nclothShapeForPart2 + '.stretchResistance', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.compressionResistance', nclothShapeForPart2 + '.compressionResistance', f=1)
                    cmd.connectAttr(nclothShapeForPart1 + '.bendResistance', nclothShapeForPart2 + '.bendResistance', f=1)
                    for o in range(0, collidersGroupOneNumber, 1):
                        edgeOne = o * 12 + 4
                        edgeTwo = edgeOne + 5
                        curveForEgde1 = cmd.duplicateCurve(chainColliderPartOne[0] + '.e[' + str(edgeOne) + ']', name=chainColliderPartOne[0] + '_edgeOne_' + str(o), ch=1, rn=0, local=0)
                        cmd.parent(curveForEgde1[0], ringsCollidersGroup)
                        curveForEgde2 = cmd.duplicateCurve(chainColliderPartOne[0] + '.e[' + str(edgeTwo) + ']', name=chainColliderPartOne[0] + '_edgeTwo_' + str(o), ch=1, rn=0, local=0)
                        cmd.parent(curveForEgde2[0], ringsCollidersGroup)
                        loftFromEdge = cmd.loft(curveForEgde1[0], curveForEgde2[0], u=1, c=0, d=1, ar=1, ch=1, n=chainColliderPartOne[0] + '_loftedSurface_' + str(o), po=0)
                        cmd.parent(loftFromEdge[0], ringsCollidersGroup)
                        cmd.setAttr(curveForEgde1[0] + '.intermediateObject', 1)
                        cmd.setAttr(curveForEgde2[0] + '.intermediateObject', 1)
                        cmd.setAttr(loftFromEdge[0] + '.intermediateObject', 1)
                        positionFollicleTransform1 = cmd.createNode('transform', name=chainColliderPartOne[0] + '_positionFollicle_' + str(o), ss=1, parent=ringsCollidersGroup)
                        positionFollicleShape1 = cmd.createNode('follicle', name=chainColliderPartOne[0] + '_positionFollicle_' + str(o) + 'Shape', ss=1, parent=positionFollicleTransform1)
                        cmd.connectAttr(loftFromEdge[0] + '.local', positionFollicleShape1 + '.inputSurface', f=1)
                        cmd.connectAttr(loftFromEdge[0] + '.worldMatrix[0]', positionFollicleShape1 + '.inputWorldMatrix', f=1)
                        cmd.connectAttr(positionFollicleShape1 + '.outRotate', positionFollicleTransform1 + '.rotate', f=1)
                        cmd.connectAttr(positionFollicleShape1 + '.outTranslate', positionFollicleTransform1 + '.translate', f=1)
                        cmd.setAttr(positionFollicleShape1 + '.parameterU', 0.5)
                        cmd.setAttr(positionFollicleShape1 + '.parameterV', 0.5)
                        cmd.setAttr(positionFollicleShape1 + '.simulationMethod', 0)
                        cmd.setAttr(positionFollicleTransform1 + '.intermediateObject', 1)
                        hiresJoint = cmd.joint(p=(0, 0, 0), name=transformNode[0] + '_hiRes_joint1_' + str(o))
                        cmd.parent(hiresJoint, hiresJointGroup)
                        hiresJointCNS = cmd.parentConstraint(positionFollicleTransform1, hiresJoint, mo=0, n=transformNode[0] + '_hiRes_jointCNS_' + str(o))
                        cmd.skinCluster(hiresJoint, hiResGroupOne[o])

                    for p in range(0, collidersGroupTwoNumber, 1):
                        edgeOne = p * 12 + 4
                        edgeTwo = edgeOne + 5
                        curveForEgde1 = cmd.duplicateCurve(chainColliderPartTwo[0] + '.e[' + str(edgeOne) + ']', name=chainColliderPartTwo[0] + '_edgeOne_' + str(p), ch=1, rn=0, local=0)
                        cmd.parent(curveForEgde1[0], ringsCollidersGroup)
                        curveForEgde2 = cmd.duplicateCurve(chainColliderPartTwo[0] + '.e[' + str(edgeTwo) + ']', name=chainColliderPartTwo[0] + '_edgeTwo_' + str(p), ch=1, rn=0, local=0)
                        cmd.parent(curveForEgde2[0], ringsCollidersGroup)
                        loftFromEdge = cmd.loft(curveForEgde1[0], curveForEgde2[0], u=1, c=0, d=1, ar=1, ch=1, n=chainColliderPartTwo[0] + '_loftedSurface_' + str(p), po=0)
                        cmd.parent(loftFromEdge[0], ringsCollidersGroup)
                        cmd.setAttr(curveForEgde1[0] + '.intermediateObject', 1)
                        cmd.setAttr(curveForEgde2[0] + '.intermediateObject', 1)
                        cmd.setAttr(loftFromEdge[0] + '.intermediateObject', 1)
                        positionFollicleTransform1 = cmd.createNode('transform', name=chainColliderPartTwo[0] + '_positionFollicle_' + str(p), ss=1, parent=ringsCollidersGroup)
                        positionFollicleShape1 = cmd.createNode('follicle', name=chainColliderPartTwo[0] + '_positionFollicle_' + str(p) + 'Shape', ss=1, parent=positionFollicleTransform1)
                        cmd.connectAttr(loftFromEdge[0] + '.local', positionFollicleShape1 + '.inputSurface', f=1)
                        cmd.connectAttr(loftFromEdge[0] + '.worldMatrix[0]', positionFollicleShape1 + '.inputWorldMatrix', f=1)
                        cmd.connectAttr(positionFollicleShape1 + '.outRotate', positionFollicleTransform1 + '.rotate', f=1)
                        cmd.connectAttr(positionFollicleShape1 + '.outTranslate', positionFollicleTransform1 + '.translate', f=1)
                        cmd.setAttr(positionFollicleShape1 + '.parameterU', 0.5)
                        cmd.setAttr(positionFollicleShape1 + '.parameterV', 0.5)
                        cmd.setAttr(positionFollicleShape1 + '.simulationMethod', 0)
                        cmd.setAttr(positionFollicleTransform1 + '.intermediateObject', 1)
                        hiresJoint = cmd.joint(p=(0, 0, 0), name=transformNode[0] + '_hiRes_joint2_' + str(p))
                        cmd.parent(hiresJoint, hiresJointGroup)
                        hiresJointCNS = cmd.parentConstraint(positionFollicleTransform1, hiresJoint, mo=0, n=transformNode[0] + '_hiRes_jointCNS_' + str(p))
                        cmd.skinCluster(hiresJoint, hiResGroupTwo[p])

                    ikSpline = cmd.ikHandle(sj=firstJoint[0], ee=lastJointForIK[0], sol='ikSplineSolver', ap=1, roc=1, scv=0, ccv=1, pcv=0, n=transformNode[0] + '_ikHandle')
                    cmd.connectAttr(hairOutputCurve + '.worldSpace[0]', ikSpline[0] + '.inCurve', f=1)
                    cmd.delete(ikSpline[2])
                    cmd.parent(ikSpline[0], jointGroup)
                    cmd.setAttr(ikSpline[0] + '.visibility', 0)
                    clusters = []
                    cvs = cmd.getAttr(x + '.cp', s=1)
                    for cv in range(0, cvs, 1):
                        cluster = cmd.cluster(x + '.cv[' + str(cv) + ']', n=transformNode[0] + '_cluster_' + str(cv), bf=1, rel=1)
                        cmd.setAttr(cluster[0] + '.isHistoricallyInteresting', 0)
                        clusters.append(cluster[1])
                        cmd.parent(cluster[1], clusterGroup)
                        if cv == 0:
                            cmd.connectAttr(cluster[1] + '.translate', startConstraintTransform + '.translate', f=1)
                            cmd.connectAttr(cluster[1] + '.rotate', startConstraintTransform + '.rotate', f=1)
                            cmd.setAttr(startConstraintTransform + '.intermediateObject', 1)
                        elif cv == cvs - 1:
                            cmd.connectAttr(cluster[1] + '.translate', endConstraintTransform + '.translate', f=1)
                            cmd.connectAttr(cluster[1] + '.rotate', endConstraintTransform + '.rotate', f=1)
                            cmd.setAttr(endConstraintTransform + '.intermediateObject', 1)

                    clusterNumber = len(clusters)
                    for c in range(0, clusterNumber, 1):
                        if c == 0:
                            startClusterCtrl = cmd.polyCube(n=transformNode[0] + '_startIK_Ctrl', w=depthInitValue * 1.5, h=depthInitValue * 1.5, d=depthInitValue * 1.5, sx=1, sy=1, sz=1, ch=0)
                            cmd.parent(startClusterCtrl[0], ikControlsGroup)
                            positionTempCNS = cmd.parentConstraint(clusters[c], startClusterCtrl[0], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.delete(positionTempCNS)
                            startClustersCtrlCNS = cmd.parentConstraint(startClusterCtrl[0], clusters[c], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.setAttr(startClusterCtrl[0] + '.overrideEnabled', 1)
                            cmd.setAttr(startClusterCtrl[0] + '.overrideShading', 0)
                            cmd.setAttr(startClusterCtrl[0] + '.overrideColor', 13)
                        elif c == clusterNumber - 1:
                            endClusterCtrl = cmd.polyCube(n=transformNode[0] + '_endIK_Ctrl', w=depthInitValue * 1.5, h=depthInitValue * 1.5, d=depthInitValue * 1.5, sx=1, sy=1, sz=1, ch=0)
                            cmd.parent(endClusterCtrl[0], ikControlsGroup)
                            positionTempCNS = cmd.parentConstraint(clusters[c], endClusterCtrl[0], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.delete(positionTempCNS)
                            endClustersCtrlCNS = cmd.parentConstraint(endClusterCtrl[0], clusters[c], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.setAttr(endClusterCtrl[0] + '.overrideEnabled', 1)
                            cmd.setAttr(endClusterCtrl[0] + '.overrideShading', 0)
                            cmd.setAttr(endClusterCtrl[0] + '.overrideColor', 13)
                        else:
                            middleClustersCtrl = cmd.polyPlatonicSolid(n=transformNode[0] + '_middleIK_Ctrl_' + str(c), ch=0, st=2, r=depthInitValue * 0.35)
                            cmd.parent(middleClustersCtrl[0], ikControlsGroup)
                            positionTempCNS = cmd.parentConstraint(clusters[c], middleClustersCtrl[0], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.delete(positionTempCNS)
                            middleClustersCtrlCNS = cmd.parentConstraint(middleClustersCtrl[0], clusters[c], mo=0, n=transformNode[0] + '_tempCNS')
                            cmd.setAttr(middleClustersCtrl[0] + '.overrideEnabled', 1)
                            cmd.setAttr(middleClustersCtrl[0] + '.overrideShading', 0)
                            cmd.setAttr(middleClustersCtrl[0] + '.overrideColor', 16)
                            cmd.connectAttr(transformNode[0] + '.ikCtrl_fromCVs', middleClustersCtrl[0] + '.visibility', f=1)

                    for j in jointsGroupOne:
                        if j == firstJoint[0]:
                            pass
                        else:
                            cmd.setAttr(j + '.translate', l=1)

                    for k in jointsGroupTwo:
                        cmd.setAttr(k + '.translate', l=1)

                    cmd.setAttr(jointGroup + '.intermediateObject', 1)
                    cmd.setAttr(hiresJointGroup + '.intermediateObject', 1)
                    cmd.select(chainColliderPartOne[0], chainColliderPartTwo[0], nclothOutputForPart1, nclothOutputForPart2, hiResGroupOne, hiResGroupTwo, r=1)
                    cmd.sets(e=1, forceElement='initialShadingGroup')
                    cmd.delete(targetLocatorGroup, upLocatorGroup, upCurve, newCurve, nurbsPath, rebuildNode)
                    historyNodes = cmd.listHistory(transformNode[0], x, f=1, af=1)
                    for h in historyNodes:
                        cmd.setAttr(h + '.isHistoricallyInteresting', 0)

                    cmd.select(selectedCurves)
                else:
                    cmd.select(selection)

        else:
            cmd.confirmDialog(t='Create chain from curve', m='No curves found in your current selection!', ma='center')
        cmd.delete(curveSection)
    else:
        cmd.confirmDialog(t='Create chain from curve', m='Create chain from curve works only with Maya 2012 and higher.', ma='left', button='OK')
chainCreator()
